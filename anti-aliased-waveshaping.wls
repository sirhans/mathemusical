#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Section:: *)
(*Implement a soft saturation waveshaper*)


(* ::Input:: *)
(*y[x_]:=a x^3 + b x^2 + c x + d;*)
(*soln1 =Solve[{y[1] == 1,y'[1]==0,y[-1]==-1,y'[-1]==0},{a,b,c,d}]*)
(*f[x_]:= If[x>1,1,If[x<-1,-1,x (3-x^2)/2]]*)
(*Plot[f[x]/.soln1,{x,-2,2}]*)


(* ::Section:: *)
(*Implement an antialiased waveshaping function*)


(* ::Input:: *)
(*AAWaveshaper[X_,fc_,Q_,sr_,f_]:=Module[{i,ic1, ic2, a1, a2, a3, v1, v2, v3,g,k,output,estimatedNextOutput,error},*)
(*output =X;*)
(*g = Tan[\[Pi] fc /sr];*)
(*k=1/Q;*)
(*a1 = 1/(1+g*(g+k));*)
(*a2=g*a1;*)
(*a3= g*a2;*)
(*ic1 = ic2 = v1 = v2 = v3 = 0;*)
(**)
(*For[i=1, i<=Length[X], i++,*)
(*(* process svf *)*)
(*v3 =N[X[[i]]]- ic2;*)
(*v1 =a1*ic1 + a2*v3;*)
(*v2 = ic2 + a2*ic1+ a3*v3;*)
(*(* update state *)*)
(*ic1 = 2*v1-ic1;*)
(*ic2=2*v2-ic2;*)
(*(* output *)*)
(*output[[i]] = v2;*)
(**)
(*(* update the first state variable to correct the output value in the direction of the error between the actual output and the waveshaped output *)*)
(*estimatedNextOutput = ic2 + a2*ic1+ a3*v3;*)
(*error =estimatedNextOutput - f[estimatedNextOutput];*)
(*ic1 -= error/a2;*)
(*];*)
(**)
(*output*)
(*]*)
(**)
(*length = 2^15;*)
(*input = Table[10Sin[2 \[Pi] 30 x],{x,0,1,1/length}];*)
(*output = AAWaveshaper[input,2000,0.5,48000,f];*)
(*ListLinePlot[output]*)
